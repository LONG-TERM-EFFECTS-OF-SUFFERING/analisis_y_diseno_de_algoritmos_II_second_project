\input{configuration.tex}
\input{front_page.tex}

\begin{document}

\maketitle

\pagenumbering{gobble}

\tableofcontents

\clearpage

\pagenumbering{arabic}


\section{Modelo genérico}

\subsection{Parámetros}

\begin{itemize}
	\item $n \in \mathbb{ N }$: número total de personas.

	\item $m \in \mathbb{ N }$: número total de opiniones.

	\item $p \in \mathbb{ N }^m$: vector con la distribución de personas por opinión, donde $p_i$ es el número de personas que inicialmente tienen la opinión $i \in 1\dots m$, $\sum_{ i = 1 }^m p_i = n$.

	\item $e \in [0,1]^m$: vector con los valores de extremismo de las opiniones, donde $e_i \in [0,1]$ es el valor de extremismo de la opinión $i \in 1 \dots m$.

	\item $c$: matriz de costes, donde $c_{ i,j } \in \mathbb{ R }^+$ es el coste de mover una persona de la opinión $i$ a la opinión $j$, para $i,j \in 1 \dots m$ ($c_{ i,i } = 0$).

	\item $ce$: vector de coste extra, donde $ce_i \in \mathbb{ R }^+$ es el coste adicional de mover una persona a la opinión $i$ si esa opinión estaba inicialmente vacía, para $i \in 1 \dots m$.

	\item $ct \in \mathbb{ R }^+$: coste total permitido.

	\item $M \in \mathbb{ N }$: número máximo de movimientos permitidos.
\end{itemize}

\subsection{Variables}

Una matriz $s$, donde $s_{ i,j } \in \mathbb{ N }$ es el número de personas movidas de la opinión $i$ a la opinión $j$, para $i,j \in 1 \dots m$.

Esta matriz es de dimensiones $m \times m$ y debe cumplir las siguientes restricciones:

\begin{itemize}
	\item $\sum_{ j = 1 }^m s_{ i,j } = p_i$: para cada opinión inicial $i$, la suma de personas que se mueven desde esa opinión hacia todas las demás (incluida ella misma) debe ser igual al número de personas que originalmente tenían la opinión $i$. $\sum_{ i = 1 }^m \sum_{ j = 1 }^m s_{ i,j } = n$.

	\item $s_{ i,j } \geq 0$ para todo $i,j \in 1 \dots m$.
\end{itemize}

\subsection{Restricciones}

\subsubsection{Numero de movimientos}

\begin{equation}
	\sum_{ i = 1 }^m \sum_{ j = 1 }^m s_{ i,j } \cdot \abs{ j - i } \leq M
\end{equation}

\subsubsection{Coste total}

\begin{equation}
	\sum_{ i = 1 }^m \sum_{ j = 1 }^m c_{ i,j } \left (1 + \frac{ p_i }{ n } \right ) * s_{ i,j } + \delta_{ p_j, 0 } \cdot ce_j * s_{ i,j } \leq ct
\end{equation}

$\delta_{ p_j, 0 }$ es una función indicadora que vale 1 si $p_j = 0$ y 0 en caso contrario.

\subsection{Función objetivo}

La idea es minimizar el extremismo, que se calcula con la siguiente fórmula:

\begin{equation}
	E(p^\prime,e) = \sum_{ i = 1 }^m { p^\prime }_i * e_i
\end{equation}

- $p^\prime$: vector con la distribución de personas tras aplicar los movimientos de $s$.

- $e$: vector con los valores de extremismo de las opiniones.

\subsection{Clasificación}

Aunque todas las variables de decisión son enteras, para modelar las restricciones es necesario usar variables de tipo \texttt{float}. Esto hace que el modelo sea un \emph{Programación Lineal Entera Mixta}.

\section{Implementación}

Gracias a las instrucciones de modelado de MiniZinc y la naturaleza del problema, las restricciones y la función objetivo se pueden expresar en pocas líneas de código.

La implementación puede describirse en los siguientes pasos:

\begin{itemize}
	\item Computación de distancias: para evitar el cálculo repetido de las distancias entre opiniones, se crea una matriz $d$ donde $d_{ i,j } = \abs{ i - j }$.

	\item Conservación de flujos ($\sum_{ j = 1 }^m s_{ i,j } = p_i$): se hace con el fin de que nadie "desaparezca". También se añade la restricción $s_{ i,j } \leq p_i$ para acotar dominios y acelerar la búsqueda.

	\item Cálculo de la distribución final: para calcular la distribución final se usó la fórmula $p^\prime[j] = \sum_{ i = 0 }^m s[i,j]$ $\forall j = 1\dots m$, personas que "terminan" en la opinion $j$.

	\item Integración con Python: se utiliza la librería minizinc para ejecutar el modelo de MiniZinc desde Python, permitiendo una mayor flexibilidad en la gestión de instancias y resultados.
\end{itemize}

Obsérvese que \texttt{s}, \texttt{total\_moves} y \texttt{p\'} son variables enteras, mientras que \texttt{total\_cost} y \texttt{extremism} son continuas. Por ello, el modelo es de tipo \emph{Programación Lineal Entera Mixta}.

\section{Análisis de Branch and Bound}

\subsection{Descripción del mecanismo}

\subsection{Análisis de árboles generados}

\subsection{Ejemplos con visualizador de MiniZinc}

\section{Instancias y pruebas}

\subsection{Instancias de prueba provistas}

\subsection{Instancias adicionales generadas}

\section{Análisis de resultados}

\section{Conclusiones}

\end{document}
